//给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
//
// 示例 1:
//
// 输入: 2
//输出: 1
//解释: 2 = 1 + 1, 1 × 1 = 1。
//
// 示例 2:
//
// 输入: 10
//输出: 36
//解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
//
// 说明: 你可以假设 n 不小于 2 且不大于 58。
// Related Topics 数学 动态规划
// 👍 659 👎 0


//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int integerBreak(int n) {
        //1. dp数组及下标含义：dp[n]，表示正整数n拆分乘积的最大值
        int[] dp = new int[60];
        //2. 确定递推公式：从(1, j)遍历，其中j是中点，有两种方式可以得到dp[i]，一个就是j * (i - j)，另一个是，将(i - j)拆分成多个数相加，多种拆分方式中 乘积最大的是dp[i - j]，因此dp[i] = max(j * (i - j), j * dp[i - j])
        //3. 数组初始化
        dp[1] = 1;
        dp[2] = 1;
        for (int i = 3; i <= n; i++){
            for (int j = 1; j < i; j++){
                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
            }
        }
        //4. 遍历顺序：从小到大
        //5. 举例推导：比如dp[5], 遍历：1+4 2+3 3+2 4+1
        //            那么1+4的情况，其中4还可以拆分成1+3 2+2，这样4可以获得的最大乘积之前已经由dp[4]计算得到了，因此在1+4的遍历轮次中，dp[5] = max(1*4, 1*dp[4]) = 4
        //            那么2+3的情况，其中3还可以拆分成1+2，这样3可以获得的最大乘积之前已经由dp[3]计算得到了，因此在2+3的遍历轮次中，dp[5] = max(2*3, 2*dp[3]) = 6
        //            那么3+2的情况，其中2还可以被拆分成1+1，dp[1]由dp数组初始化得到，因此在3+2的遍历轮次中，dp[5] = max(3*2, 3*dp[2]) = 6
        //            那么4+1的情况，其中1不能被拆分，dp[1]由dp数组初始化得到，因此在4+1的遍历轮次中，dp[5] = max(4*1, 4*dp[1]) = 4
        //            最后比较遍历过程中dp[5]的最大值，可以知道dp[5] = 6
        return dp[n];
    }
}
//leetcode submit region end(Prohibit modification and deletion)
